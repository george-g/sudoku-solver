# Sudoku Solver

## Сборка.

Сборка производится с использованием JDK 1.8.
1. Зайти в папку проекта
2. Запустить mvn clean install
3. В папке target появится sudoku-solver-1.0.jar 

## Запуск

1. Собрать jar файл sudoku-solver-1.0.jar или использовать имеющийся 
2. В папке с sudoku-solver-1.0.jar выполнить: ```java -jar sudoku-solver-1.0.jar 013800405024605000087000930490306000001000500000701093069000740000207680102008350```
3. В ответ будет напечатано ```613879425924635178587124936498356217731982564256741893869513742345297681172468359```

Для решения другого примера, просто нужно после названия jar файла ввести этот пример. 0 используется для пустых клеток.       


## Принятые решения

Несмотря на то, что задание было на английском языке, было решено использовать русский язык для написания данного файла, а так же для  комментариев в коде.
Причины для такого решения две. Первая - ограничение по времени. Создать документ на русском будет гораздо быстрее. Вторая - так как проверять задание будут в Омске, русский язык не будет для этого препятствием.   

Для решения Судоку используются множество техник. 
На сайте [sudokuwiki.org](https://www.sudokuwiki.org/) представлено около 40 таких техник, сгруппированных по сложности.   
Однако, даже этих техник может быть недостаточно для решения поставленной задачи.

Вместе с тем, корректно поставленная задача всегда может быть решена с помощью единственной техники - перебора всех вариантов.
Минус данного подхода - для сложных задач решение может искаться в течении минут (на современной технике).

Так как времени на создание Sudoku Solver отведено не много, был выбран второй вариант. Нужно реализовать всего один алгоритм (а не 40), который всегда приведет к нужному решению. 
   
Так как поиск решения может рассматриваться как задача ["до раскраски"](Precoloring_extension), за основу был выбран "Точный  алгоритм  раскрашивания" описанный в [1](#####1) ($ 10.7.3.):
> Рассмотрим  следующую  схему  рекурсивной  процедуры  Р: 
> 1.  Выбрать в графе G некоторое максимальное независимое  множество  вершин  S. 
> 2.  Покрасить  вершины  множества  S  в очередной  цвет. 
> 3.  Применить  процедуру  Р  к  графу  G — S. 

Точный алгоритм необходим, так как только он может привести к правильному решению, где каждая клетка поля (вершина графа) будет иметь значение от 1 до 9 
(раскрашена в цвет от 1 до 9). Ускоренные алгоритмы в большинстве задач приводят к тому, что появляются клетки со значением 10 и поэтому не подходят.
Рекурсивный характер алгоритма не является недостатком в данном случае, так как хроматическое число для данного графа заранее известно и оно равно 9. 
Значит и количество рекурсивных вызовов в стеке не превысит 9.

Везде где возможно вместо массивов, списков или множеств использовались класс BitSet или integer который рассматривался как набор битов. 
Это не premature optimization. Этот выбор был сделан для удобства разработки. Тем не менее, уверен, что производительность при реализации на коллекциях была бы хуже.

Для разработки был выбран JDK 8. Он уже был установлен и поэтому выбор пал на него. Компиляция байт-кода настроена на JRE 8. Впрочем, можно перевести и на использование JRE 1.0 (если потребуется). 

## Внутренне представление судоку

Внутренне представление поля судоку: массив из 81 одного целочисленного значения от 0 до 9 (массив окраски вершин). Значение 0 присвоено не окрашенным вершинам. Индекс каждой вершины можно определить по следующей таблице:

|  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|9|10| 11|12|13|14|15|16|17|
|18|19|20|21|22|23|24|25|26|
|27|28|29|30|31|32|33|34|35|
|36|37|38|39|40|41|42|43|44|
|45|46|47|48|49|50|51|52|53|
|54|55|56|57|58|59|60|61|62|
|63|64|65|66|67|68|69|70|71|
|72|73|74|75|76|77|78|79|80|      

Для выбранного алгоритма предпочтительный способ представления графа - *списки смежности*. Т.е. массивом, размер которого равен количеству вершин графа, 
а конкретное i-тое значение в нем - другой массив, содержащий все вершины смежные с i-той. Например для вершины 0, по правилам судоку, смежные вершины 
по горизонтали: 1, 2, 3, 4, 5, 6, 7, 8. По вертикали: 9, 18, 27, 36, 45, 54, 63, 72. По квадрату 3x3: 1, 2, 3, 9, 10, 11, 18, 19, 20.
Таким образом, для получаем список смежности для вершины 0: 
```список_смежности[0] == {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 18, 19, 20, 27, 36, 45, 54, 63, 72}```
   

## Точный  алгоритм  раскрашивания ```solve```
Вход: массив окраски вершин
Выход: массив окраски вершин или null, если докрасить значение полученное на входе невозможно

0. Если неокрашенных вершин нет - вернуть список вершин полученный на входе.
1. Для всех неокрашенных вершин подбираем возможные цвета
2. Определяем переменную selectedColor - выбираем цвет, который встречается на шаге 1 реже всего.
2. Определяем переменную powerOfCombination - для выбранного цвета определяем, сколько неокрашенных клеток может содержать этот цвет (9 минус кол-во клеток окрашеных в этот цвет)
3. Для выбранного цвета создаем список, в котором перечислены все вершины для которых данный цвет возможен. 
4. Определяем переменную independentNodes - используется алгоритм getIndependentNodes который извлекает из списка полученном в предыдущем шаге списки независимых вершин. 
(Список полученный в предыдущем шаге содержит в себе взаимозависимые вершины. Комбинации содержащие зависимые вершины заведомо некорректны. Комбинации создаются на следующем шаге)
5. Из списков полученных на предыдушем шаге, с помощью алгоритма nextCombination создаем комбинацию для проверки.
6. Копируем входной массив окраски вершин
7. Модифицируем копию массива окраски - вершинам которые приведены в комбинации присваиваем выбранный цвет selectedColor.
8. Вызываем solve с модифицированной копией массива окраски (рекурсивный вызов)


## Алгоритма поиска списков независимых вершин ```getIndependentNodes```

Вход: массив вершин (массив_вершин)
Выход: массивы взаимонезависимых вершин

1. Вводим переменные I = 0 и J = 1;
2. Вводим переменную с результатом R
2. Начало цикла 
3. Если дошли до конца массив_вершин вернуть R
4. По спискам смежности проверить смежность вершин массив_вершин[i] и массив_вершин[j] 
5. Если вершины не смежны, добавить в результат в R
6. Вернуться в начало цикла

## Алгоритм генерации комбинации nextCombination

*Этот алгоритм лучше переписать в рекурсивном виде. Однако на это времени не осталось*

Вход: предыдущая комбинация (X), списки независимых вершин (I), мощность требуемой комбинации (P)
Выход: комбинация

1. Создаем переменную результата R
2. Если X == null то R := новый массив длинной P, иначе R := X
3. Берем предпоследний элемент R - LL и последний елемент R - L 
4. Если для элемента LL не существует независимой вершины в I индекс которой больше L повторяем предыдущий шаг. Только на этот раз LL и L будут браться на одну позицию дальше от левого края.
5. Получаем индекс независимой вершины для LL, которая по значению больше чем L
7. Присваиваем соответствующему элементу R значение полученное в предыдущем шаге. 
8. Если это был последний элемент R то вернуть R
9. Вернуться на шаг 5        

Список использованной литературы:
##### 1
>Ф. А. Новиков “Дискретная математика для программистов” 3-е издание
##### 2
>Sudoku Squares and Chromatic Polynomials Agnes by M. Herzberg and M. Ram Murty https://www.ams.org/notices/200706/tx070600708p.pdf
##### 3
>New Graph Coloring Algorithms by Dr. Hussein Al-Omari and Khair Eddin Sabri https://core.ac.uk/download/pdf/25782121.pdf
##### 4
>https://www.sudokuwiki.org/
##### 5
>https://stolaf.edu/people/hansonr/sudoku/    